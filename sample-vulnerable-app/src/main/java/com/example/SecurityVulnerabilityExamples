package com.example;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Random;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

/**
 * WARNING: This class contains intentional security vulnerabilities for demonstration purposes.
 * DO NOT use this code in production!
 */
public class SecurityVulnerabilityExamples {
    
    // VULNERABILITY 1: Hardcoded credentials
    private static final String DB_PASSWORD = "admin123";
    private static final String API_KEY = "sk_live_1234567890abcdef";
    private static final String SECRET_TOKEN = "my-secret-token-12345";
    
    // VULNERABILITY 2: SQL Injection
    public void vulnerableSqlQuery(String userId) throws Exception {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db", "root", DB_PASSWORD);
        Statement stmt = conn.createStatement();
        
        // Direct string concatenation - SQL Injection vulnerability
        String query = "SELECT * FROM users WHERE user_id = '" + userId + "'";
        ResultSet rs = stmt.executeQuery(query);
        
        while (rs.next()) {
            System.out.println(rs.getString("username"));
        }
    }
    
    // VULNERABILITY 3: Path Traversal
    public File vulnerableFileAccess(String filename) {
        // User-controlled path without validation - Path Traversal vulnerability
        return new File("/var/data/" + filename);
    }
    
    // VULNERABILITY 4: Command Injection
    public void vulnerableCommandExecution(String userInput) throws IOException {
        // Direct command execution with user input - Command Injection vulnerability
        Runtime.getRuntime().exec("ping -c 4 " + userInput);
    }
    
    // VULNERABILITY 5: XSS (Cross-Site Scripting)
    public void vulnerableXss(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String userInput = request.getParameter("name");
        // Direct output without sanitization - XSS vulnerability
        response.getWriter().write("<html><body>Hello " + userInput + "</body></html>");
    }
    
    // VULNERABILITY 6: Weak Random Number Generator
    public String generateSessionToken() {
        // Using predictable Random instead of SecureRandom
        Random random = new Random();
        return "token_" + random.nextInt();
    }
    
    // VULNERABILITY 7: XXE (XML External Entity) Injection
    public void vulnerableXmlParsing(String xmlInput) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        // XXE vulnerability - external entities not disabled
        DocumentBuilder builder = factory.newDocumentBuilder();
        builder.parse(xmlInput);
    }
    
    // VULNERABILITY 8: Insecure Deserialization
    public Object vulnerableDeserialization(String filename) throws Exception {
        FileInputStream fileIn = new FileInputStream(filename);
        ObjectInputStream in = new ObjectInputStream(fileIn);
        // Deserializing untrusted data - Insecure Deserialization vulnerability
        Object obj = in.readObject();
        in.close();
        fileIn.close();
        return obj;
    }
    
    // VULNERABILITY 9: Information Exposure
    public void exposeSensitiveInfo(Exception e) {
        // Printing full stack traces - Information Exposure
        e.printStackTrace();
        System.out.println("Database connection string: jdbc:mysql://prod-db.company.com:3306/production");
    }
    
    // VULNERABILITY 10: Insecure Cookie
    public void setInsecureCookie(HttpServletResponse response) {
        // Cookie without Secure and HttpOnly flags
        response.addHeader("Set-Cookie", "sessionId=abc123; Path=/");
    }
    
    // VULNERABILITY 11: LDAP Injection
    public String vulnerableLdapQuery(String username) {
        // LDAP injection through unvalidated user input
        return "(&(objectClass=user)(uid=" + username + "))";
    }
    
    // VULNERABILITY 12: Null Pointer Dereference
    public void vulnerableNullCheck(String input) {
        String value = null;
        if (input.equals("test")) {
            value = "valid";
        }
        // Potential null pointer dereference
        System.out.println(value.length());
    }
    
    // VULNERABILITY 13: Resource Leak
    public String vulnerableResourceHandling(String filename) throws Exception {
        FileInputStream fis = new FileInputStream(filename);
        // Resource not properly closed - Resource Leak
        byte[] data = new byte[1024];
        fis.read(data);
        return new String(data);
    }
    
    // VULNERABILITY 14: Weak Cryptographic Algorithm
    public String weakEncryption(String password) throws Exception {
        // Using weak MD5 algorithm
        java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5");
        byte[] hash = md.digest(password.getBytes());
        return new String(hash);
    }
    
    // VULNERABILITY 15: Trust Boundary Violation
    public void trustBoundaryViolation(HttpServletRequest request) {
        // Storing user input directly in session without validation
        String userRole = request.getParameter("role");
        request.getSession().setAttribute("userRole", userRole);
    }
}
